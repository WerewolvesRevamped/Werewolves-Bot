/**
Loot Boxes
**/

module.exports = function() {

    this.ALL_LOOT = [["SP:1","Glitch","Gold",1],["STD:RE","Reroll","Silver",1],["BOT:TEMP","$temp Command","Silver",1],["GM:Ts","Kill Ts","Platinum",0.5],["AL:Town","Townsfolk Alignment Guarantor","Silver",2],["IC:Cat","Cat Icon","Platinum",1],["DM:1","Realsad","Silver",1],["SP:2","Negate","Silver",2],["COIN:50","50 Coins","Bronze",2],["BOT:REV","$reverseme Command","Gold",1],["GM:Eth","Demote Ethan","Gold",0.5],["AL:Wolf","Werewolves Alignment Guarantor","Silver",2],["IC:Devil","Devil Icon","Gold",1],["DM:2","Salute","Bronze",1],["SP:3","Grayscale","Bronze",2],["COIN:120","120 Coins","Silver",2],["BOT:SHIP","$newship Command","Platinum",1],["GM:Luf","Rename Luffy","Gold",0.5],["AL:UA","Unaligned Alignment Guarantor","Gold",1],["IC:Hooker","Hooker Icon","Silver",1],["DM:3","Rating","Silver",1],["SP:5","Emboss","Bronze",1],["COIN:160","160 Coins","Gold",2],["BOT:HATE","$newhate Command","Platinum",1],["GM:Krem","Turn Krem into a Little Bug","Gold",0.5],["AL:Solo","Solo Alignment Guarantor","Gold",1],["IC:Medium","Medium Icon","Silver",1],["SP:6","Silhouette","Bronze",1],["STD:RE2","Reroll x2","Gold",1],["BOT:FLIP","$flip Command","Bronze",1],["GM: Jay","Tempt Jay into sinning","Platinum",0.5],["AL:Hell","Hell Alignment Guarantor","Platinum",1],["IC:Executioner","Executioner Icon","Bronze",1],["SP:7","Pixel","Silver",1],["STD:BTNT","Be the next theme","Platinum",0.5],["BOT:FORTUNE","$fortune Command","Bronze",1],["GM:Kruth","Demote Kruthers","Silver",0.5],["AL:HM","Horseman Alignment Guarantor","Platinum",0.5],["IC:Witch","Witch Icon","Gold",1],["SP:9","Pixel #3","Silver",1],["STD:JOKE","Your own Joke Role","Platinum",0.5],["GM:Fish","Kill Mr. Fish","Silver",0.5],["AL:Pyro","Pyro Alignment Guarantor","Platinum",1],["IC:Saboteur Wolf","Saboteur Wolf Icon","Bronze",1],["SP:12","Red","Bronze",2],["STD:X","Unlucky (Nothing)","Bronze",1],["GM:Arch","Demote Jean D. Arch","Silver",0.5],["AL:Flute","Flute Alignment Guarantor","Platinum",1],["IC:Archivist Fox","Archivist Fox Icon","Silver",1],["SP:13","Green","Bronze",2],["STD:RE3","Reroll x3","Platinum",0.5],["GM:Fed","Kill Federick","Bronze",0.5],["AL:WWW","White Wolves Alignment Guarantor","Platinum",0.5],["IC:Lone Wolf","Lone Wolf Icon","Gold",1],["SP:14","Blue","Bronze",2],["STD:Icon","Custom Icon","Platinum",1],["GM:Ghost","Exorcise Gh0st","Silver",0.5],["AL:Plague","Plague Alignment Guarantor","Platinum",0.5],["IC:Flute Player","Flute Player Icon","Silver",1],["SP:15","Yellow","Bronze",2],["STD:Theme","Suggest a Theme","Gold",0.5],["GM:Katy","Kill KatyHawk","Bronze",0.5],["AL:UW","Underworld Alignment Guarantor","Platinum",0.5],["IC:Pyromancer","Pyromancer Icon","Gold",1],["SP:16","Purple","Bronze",2],["STD:CMD","Custom Bot Command","Platinum",0.5],["GM:Marten","Promote Marten","Platinum",0.5],["AL:T/W","Townsfolk/Werewolves Alignment Guarantor","Bronze",2],["IC:Plague Bearer","Plague Bearer Icon","Gold",1],["SP:17","Cyan","Bronze",2],["GM:Turtle","Demote Mr. Turtle","Gold",0.5],["IC:Vampire","Vampire Icon","Gold",1],["SP:18","Flip","Bronze",1],["GM:Stein","Take Steinator as a Hostage","Gold",0.5],["CAT:Misc","Miscellaneous Category Guarantor","Bronze",1],["IC:Angel","Angel Icon","Gold",1],["SP:20","BW","Bronze",1],["BOT:invtransfer","$inventory transfer Command","",],["GM:Vera","Evict Vera","Platinum",0.5],["CAT:Power","Power Category Guarantor","Silver",1],["IC:Hellhound","Hellhound Icon","Silver",1],["SP:21","Wire","Gold",2],["CAT:Invest","Investigative Category Guarantor","Gold",1],["IC:Bear","Bear Icon","Platinum",1],["SP:24","Rainbow #2","Silver",1],["CAT:Kill","Killing Category Guarantor","Gold",0.5],["IC:White Werewolf","White Werewolf Icon","Silver",1],["SP:25","Rainbow #3","Silver",1],["CAT:!Misc","Not-Miscellaneous Category Guarantor","Bronze",1],["IC:Reaper","Reaper Icon","Platinum",1],["SP:26","Ts","Platinum",0.5],["IC:Herding Dog","Herding Dog Icon","Silver",1],["SP:27","Oil","Silver",1],["IC:Bard","Bard Icon","Bronze",1],["SP:28","Wave","Bronze",1],["IC:Cerberus","Cerberus Icon","Bronze",1],["SP:29","Swirl","Bronze",1],["SPEC:AnySkinpack","(SPECIAL) Any Skinpack","Platinum",0.05],["IC:Lover","Lover Icon","Bronze",1],["SP:31","Cycle","Silver",1],["SPEC:AnyIcon","(SPECIAL) Any Icon","Platinum",0.05],["IC:Citizen","Citizen Icon","Bronze",1],["SP:32","Equalize","Bronze",1],["SPEC:AnyGuarantor","(SPECIAL) Any Guarantor","Platinum",0.05],["IC:Devout Villager","Devout Villager Icon","Bronze",1],["SP:33","Fourier Noise","Gold",1],["SPEC:Any","(SPECIAL) Any Prize","Platinum",0.01],["IC:Baroness","Baroness Icon","Bronze",1],["SP:35","Fourier Oil","Gold",1],["SP:36","Fourier Modulate","Platinum",2],["SP:37","Fourier Wire","Silver",0.5],["SP:38","Glitch #2","Gold",1],["SP:39","Eyes","Gold",1],["SP:40","Thief","",],["SP:41","Mask","Silver",0.5],["SP:42","Eye","Gold",2],["SP:43","Fourier Eye","Gold",0.5],["SP:44","Citizen Eye","Silver",0.5],["SP:45","Items","Gold",1],["SP:46","Bear","Platinum",2],["SP:47","Wolfify","Gold",1],["SP:48","Grid","Gold",1],["SP:49","Light and Shadow","Silver",1],["SP:50","Duo Color","Gold",1],["SP:51","Wood","Bronze",1],["SP:52","Coin","Gold",1],["SP:53","Coin Animated","Platinum",1],["SP:54","Glitch Animated","Platinum",1],["SP:55","Wave Animated","Silver",0.5],["SP:56","Spin","Gold",1],["SP:57","Rainbow Animated","Platinum",1]];

    /**
    Command: $loot
    **/
    this.tierNames = ["Bronze", "Silver", "Gold","Platinum", "Cheated"];
    let tierColors = [9785610, 13027014, 14922018, 10877429, 15469740];
    let tierIcons = ["Extras/Token%20Bronze", "Extras/Token%20Silver", "Extras/Token", "Extras/Token%20Platinum", "Extras/Bot%20Developer"];
    let tierCoins = [10, 20, 50, 100, 0];
    this.cmdLoot = async function(message) {
        // check coins
        let coinCount = await getCoins(message.member.id);
        if(coinCount < 100) {
            let embed = { title: "Insufficient Coins", description: "You need to have at least `100` coins to open a loot box!\n\nYou have: `" + coinCount + "`.", color: 16715021 };
            embed.thumbnail = { url: `${iconRepoBaseUrl}Extras/Token%20Insufficient.png` };
            message.channel.send({ embeds: [ embed ] });
            return;
        }
        await modifyCoins(message.member.id, -100);
        
        // open box
        await openBox(message.channel, message.member.id);
    }
    
    /**
    Command: $loot_force
    **/
    this.cmdLootForce = async function(message, args) {
        if(!args[0]) {
            channel.send("⛔ Syntax error. Not enough parameters!");
            return;
        }
        // search for reward
        let reward = ALL_LOOT.filter(el => el[0].toLowerCase() === args[0].toLowerCase());
        if(reward.length != 1) {
            message.channel.send("⛔ Command error. Could not find reward!");
            return;
        }
        
        // open box
        openBox(message.channel, message.member.id, reward[0]);
    }
    
    /**
    Command: $inventory
    **/
    this.cmdInventory = async function(message, args) {
        if(!args[0]) { 
            cmdInventorySee(message.channel, message.member.id);
			return; 
		} 
		// Check Subcommand
		switch(args[0]) {
			case "see": cmdInventorySee(message.channel, message.member.id); break;
			case "get": if(checkGM(message)) cmdInventoryGet(message.channel, args); break;
            case "remove": if(checkGM(message)) cmdInventoryRemove(message.channel, args); break;
            case "add": if(checkGM(message)) cmdInventoryAdd(message.channel, args); break;
            case "transfer": 
                let transferPerms = await inventoryGetItem(message.author.id, "bot:invtransfer");
                if(transferPerms === 0) {
                    message.channel.send(`⛔ You have not unlocked the ${stats.prefix}inventory transfer command.`);
                    return;
                } 
                cmdInventoryTransfer(message.channel, message.author.id, args); break;
			default: message.channel.send("⛔ Syntax error. Invalid subcommand `" + args[0] + "`!"); break;
		}
    }
    
    /**
    Command: $inventory get
    **/
    this.cmdInventoryGet = async function(channel, args) {
        // Check arguments
		if(!args[1]) { 
			channel.send("⛔ Syntax error. Not enough parameters! Correct usage: `" + stats.prefix + "inventory get <player>`!"); 
			return; 
		}
        // Get user
		let user = parseUser(channel, args[1]);
		if(!user) { 
			// Invalid user
			channel.send("⛔ Syntax error. `" + args[1] + "` is not a valid player!"); 
			return; 
		} 
        await cmdInventorySee(channel, user);
    }
    
    /**
    Command: $inventory remove
    **/
    this.cmdInventoryRemove = async function(channel, args) {
        // Check arguments
		if(!args[1]) { 
			channel.send("⛔ Syntax error. Not enough parameters! Correct usage: `" + stats.prefix + "inventory remove <player> <item>`!"); 
			return; 
		}
        // Get user
		let user = parseUser(channel, args[1]);
        // Invalid user
		if(!user) { 
			channel.send("⛔ Syntax error. `" + args[1] + "` is not a valid player!"); 
			return; 
		} 
        // Get item
        let item = ALL_LOOT.filter(el => el[0].toLowerCase() === args[2].toLowerCase());
        // Invalid item
		if(item.length != 1) { 
			channel.send("⛔ Command error. `" + args[2] + "` is not a valid item!"); 
			return; 
		} 
        let code = item[0][0];
        
        // get item count
        let count = await inventoryGetItem(user, code);
        if(count <= 0) {
			channel.send("⛔ Command error. Insufficient item count!"); 
			return; 
        }
        
        // update item count
        let updatedCount = await inventoryModifyItem(user, code, -1);
        channel.send(`✅ Removed a ${item[0][1]} (${code}) from <@${user}>'s inventory. Count now is \`${updatedCount}\`.`);
    }
    
    /**
    Command: $inventory transfer
    **/
    this.cmdInventoryTransfer = async function(channel, authorid, args) {
        // Check arguments
		if(!args[1] || !args[2]) { 
			channel.send("⛔ Syntax error. Not enough parameters! Correct usage: `" + stats.prefix + "inventory transfer <player> <item>`!"); 
			return; 
		}
        // Get user
		let user = parseUser(channel, args[1]);
        // Invalid user
		if(!user) { 
			channel.send("⛔ Syntax error. Not a valid player!"); 
			return; 
		} 
        
        // Get item
        let item = ALL_LOOT.filter(el => el[0].toLowerCase() === args[2].toLowerCase());
        // Invalid item
		if(item.length != 1) { 
			channel.send("⛔ Command error. Not a valid item! Make sure to use the item code as specified in your inventory."); 
			return; 
		} 
        let code = item[0][0];
        
        // get item count
        let count = await inventoryGetItem(authorid, code);
        if(count <= 0) {
			channel.send("⛔ Command error. Insufficient item count! Check your inventory to make sure you have this item."); 
			return; 
        }
        
        // update item count
        await inventoryModifyItem(authorid, code, -1);
        await inventoryModifyItem(user, code, 1);
        channel.send(`✅ Transfered a ${item[0][1]} (${code}) from <@${authorid}> to <@${user}>!`);
    }
    
    /**
    Command: $inventory add
    **/
    this.cmdInventoryAdd = async function(channel, args) {
        // Check arguments
		if(!args[1]) { 
			channel.send("⛔ Syntax error. Not enough parameters! Correct usage: `" + stats.prefix + "inventory add <player> <item>`!"); 
			return; 
		}
        // Get user
		let user = parseUser(channel, args[1]);
        // Invalid user
		if(!user) { 
			channel.send("⛔ Syntax error. `" + args[1] + "` is not a valid player!"); 
			return; 
		} 
        // Get item
        let item = ALL_LOOT.filter(el => el[0].toLowerCase() === args[2].toLowerCase());
        // Invalid item
		if(item.length != 1) { 
			channel.send("⛔ Command error. `" + args[2] + "` is not a valid item!"); 
			return; 
		} 
        let code = item[0][0];
        
        // update item count
        let updatedCount = await inventoryModifyItem(user, code, 1);
        channel.send(`✅ Added a ${item[0][1]} (${code}) to <@${user}>'s inventory. Count now is \`${updatedCount}\`.`);
    }
    
    /**
    Command: $inventory see
    **/
    this.cmdInventorySee = async function(channel, user) {
                
        let items = await sqlPromEsc("SELECT * FROM inventory WHERE player=", user);
        items = items.map(el => [el.count, el.item.toUpperCase(), ALL_LOOT.filter(el2 => el2[0].toLowerCase() === el.item)[0]]);
        
        // no items
        if(items.length === 0) {
            let embed = { title: "Inventory", description: `<@${user}>, your inventory is currently empty!`, color: 8984857 };
            channel.send({ embeds: [ embed ] });
            return;
        }
        
        if(items.length > 10) { // >10 items
            // format item list
            let items1 = [], items2 = [];
            let half = Math.ceil(items.length / 2);
            for(let i = 0; i < half; i++) items1.push(`• ${items[i][2][1]} x${items[i][0]}`);
            if(items.length > 1) for(let i = half; i < items.length; i++) items2.push(`• ${items[i][2][1]} x${items[i][0]} (\`${items[i][1]}\`)`);
            let embed = { title: "Inventory", description: `<@${user}>, here is your current inventory:`, color: 8984857, fields: [ {}, {} ] };
            embed.fields[0] = { name: "_ _", "value": items1.join("\n"), inline: true };
            embed.fields[1] = { name: "_ _", "value": items2.join("\n"), inline: true };
            embed.thumbnail = { url: `${iconRepoBaseUrl}Offbrand/Inventory.png` };
            channel.send({ embeds: [ embed ] });
        } else { // <=10 items
            // format item list
            let itemsTxt = [];
            for(let i = 0; i < items.length; i++) itemsTxt.push(`• ${items[i][2][1]} x${items[i][0]} (\`${items[i][1]}\`)`);
            let embed = { title: "Inventory", description: `<@${user}>, here is your current inventory:\n\n` + itemsTxt.join("\n"), color: 8984857 };
            embed.thumbnail = { url: `${iconRepoBaseUrl}Offbrand/Inventory.png` };
            channel.send({ embeds: [ embed ] });
        }
    }
    
    /**
    Open Loot Box
    **/
    this.openBox = async function(channel, pid, overwrite = null, possibleTiers = null) {
        let tierRand = Math.random();
        let tier = 0;
        if(tierRand >= 0.95) tier = 3;
        else if(tierRand >= 0.8) tier = 2;
        else if(tierRand >= 0.5) tier = 1;
        
        if(possibleTiers) {
            if(!possibleTiers.includes(tier)) {
                tier = possibleTiers[Math.floor(Math.random() * possibleTiers.length)];
            }
        }
        
        // filter out tier rewards
        let filteredRewards = ALL_LOOT.filter(el => el[2] === tierNames[tier]);
        let totalWeights = filteredRewards.map(el => el[3]).reduce((a,b) => a+b, 0);
        let lootRand = Math.random() * totalWeights;
        
        console.log("Loot Box", tierRand, lootRand, totalWeights);
        
        // find reward
        let acc = 0;
        let reward = null;
        for(let i = 0; i < filteredRewards.length; i++) {
            acc += filteredRewards[i][3];
            if(lootRand < acc) {
                reward = filteredRewards[i];
                break;
            }
        }
        
        // overwrite reward
        if(overwrite) {
            reward = overwrite;
            tier = 4;
        }
                
        // unlock reward
        let result = await unlockReward(channel, pid, reward);
        if(!result) {
            await modifyCoins(pid, tierCoins[tier]);
        }
        
        let embed = { title: "Lootbox opened!", description: `<@${pid}> opened a loot box and got a **${tierNames[tier].toUpperCase()}** tier reward!\n\n**__You won:__** ${rewardToText(reward)}` + (!result ? `\n\nYou already have this reward so as a consolation prize you get ${tierCoins[tier]} ${getEmoji('token')} coins.` : ""), color: tierColors[tier] };
        embed.thumbnail = { url: iconRepoBaseUrl + tierIcons[tier] + ".png?v=2" };
        embed.image = { url: `https://werewolves.me/images/${tierNames[tier]}.png?v=5` };
        channel.send({ embeds: [ embed ] });
        
        // log reward
        if(stats.reward_log) {
            let rl = mainGuild.channels.cache.get(stats.reward_log);
            rl.send(`<@${pid}> opened a **${tierNames[tier]}** loot box and got **${reward[0]}** (\`${reward[1]}\`).` + (!result ? ` [Consolation: ${tierCoins[tier]}]` : ""));
        }
    }
    
    /**
    Returns a rewards type
    **/
    function getRewardType(reward) {
        let typ = reward[0];
        return typ.split(":")[0].toLowerCase();
    }
    
    /**
    Returns a rewards id
    **/
    function getRewardID(reward) {
        let typ = reward[0];
        return typ.split(":")[1].toLowerCase();
    }
    
    /**
    Converts a reward to text
    **/
    const VOUCHER = "This voucher has been added to your inventory.";
    function rewardToText(reward) {
        let id = getRewardID(reward);
        switch(getRewardType(reward)) {
            // SKINPACKS
            case "sp":
                id = +id;
                let code = AVAILABLE_PACKS[id - 1];
                let em = getEmoji("pack_" + code);
                if(ANIMATED_PACKS.includes(id)) {
                    return `The ${em} **${reward[1]}** ${em} skinpack. Use \`$packs select ${id}\` to select it. Warning! This is an animated skinpack and may contain flashing images.`;
                } else {
                    return `The ${em} **${reward[1]}** ${em} skinpack. Use \`$packs select ${id}\` to select it.`;
                }
            break;
            // STANDARD
            case "std":
                switch(reward[0].toLowerCase()) {
                    case "std:re": return "A free lootbox re-roll!";
                    case "std:re2": return "__Two__ free lootbox re-rolls!";
                    case "std:re3": return "__Three__ free lootbox re-rolls!";
                    case "std:x": return "Nothing! You got unlucky. 😭";
                    case "std:btnt": return `Be the next theme! (Some conditions apply). ${VOUCHER} Redeem by notifying GMs before a game is announced.`;
                    case "std:joke": return `Get your own joke role! (Some conditions apply). ${VOUCHER} Redeem by notifying a GM.`;
                    case "std:icon": return `Get a custom WWR Role Icon made for you. ${VOUCHER} Redeem by notifying Vera. Terms and conditions may apply.`;
                    case "std:cmd": return `Get a custom WWR Bot Joke Command made for you. Redeem by notifying Ts. Terms and conditions may apply.`;
                    case "std:theme": return `Suggest a theme for an upcoming game. ${VOUCHER} Redeem by notifying a Host or Game Master. You must use this before the theme for the next game is decided/announced. Theme suggestions must be reasonable and terms and conditions may apply. Some themes may be rejected (with the voucher being refunded). If you cannot get your theme accepted, you may be able to exchange this voucher for 100 coins.`;
                    default: return `An unknown standard reward: ${reward[1]}.`;
                }
            break;
            // COIN
            case "coin":
                return `${id} coins. Use \`${stats.prefix}coins\` to check your coins.`;
            break;
            break;
            // GM
            case "gm":
                return `A special action: ${reward[1]}. This action has been added to your inventory. Redeem by notifying an Admin of your choice while there is no game.`;
            break;
            // AL
            case "al":
                return `An alignment guarantor for: ${reward[1].split(" ")[0]}. You may use this during the signup/setup phase of a game to affect your alignment. To do so DM one of the Hosts. You may __not__ let anyone know you used an alignment guarantor until after the game is completed. Alignment guarantors may be rejected for some games (e.g. when the alignment is not present).`;
            break;
            // CAT
            case "cat":
                return `A category guarantor for: ${reward[1].split(" ")[0]}. You may use this during the signup/setup phase of a game to affect your role's category. To do so DM one of the Hosts. You may __not__ let anyone know you used a category guarantor until after the game is completed. Category guarantors may be rejected for some games (e.g. when the category is not present).`;
            break;
            // Special
            case "spec":
                return `A special reward: ${reward[1]} These are the rarest rewards there are and almost impossible to obtain through a loot box! Ask a Game Master to redeem it.`;
            break;
            // Icon
            case "ic":
                let rName = reward[1].toLowerCase().replace(" icon", "");
                let rText = rName.indexOf(" ") > 0 ? `"${rName}"` : rName;
                return `A custom icon role for: ${toTitleCase(rName)} ${getEmoji(rName)}. You may enable this role with \`${stats.prefix}icon set ${rText}\`.`;
            break;
            // Death Message
            case "dm":
                let dmName = reward[1].toLowerCase();
                return `A custom death message: ${toTitleCase(dmName)}. You may enable this death message with \`${stats.prefix}dmsg set ${id}\`.`;
            break;
            // Bot
            case "bot":
                switch(reward[0].toLowerCase()) {
                    case "bot:temp": return `Access to the epic, amazing and ultra-exclusive ${stats.prefix}temp command. Give it a try!`;
                    case "bot:rev": return `Access to the ${stats.prefix}reverseme command. Spice up your nickname... by reversing it? Give it a try!`;
                    case "bot:ship": return `Access to the ${stats.prefix}newship command. Are you having trouble in your love life? WWR Bot is here to help with useful suggestions of potential ships. Give it a try!`;
                    case "bot:hate": return `Access to the ${stats.prefix}newhate command. Are you looking to get angry but don't know who to be mad at? WWR Bot will offer useful suggestions of who to pick a fight with. Give it a try!`;
                    case "bot:flip": return `Access to the ${stats.prefix}flip command. Bored of the good old ${stats.prefix}roll command? Try this command to flip a coin and spice things up!`;
                    case "bot:fortune": return `Access to the ${stats.prefix}fortune command. Let me tell your fortune!`;
                    default: return `An unknown bot reward: ${reward[1]}.`;
                }
            default:
                return `A reward of unknown type: ${reward[1]}.`;
            break;
        }
    }
    
    /**
    Unlocks a reward
    **/
    async function unlockReward(channel, pid, reward) {
        let id = getRewardID(reward);
        switch(getRewardType(reward)) {
            // STANDARD
            case "std":
                switch(reward[0].toLowerCase()) {
                    case "std:re":
                        setTimeout(function() { openBox(channel, pid) }, 3000);
                        return true;
                    case "std:re2":
                        setTimeout(function() { openBox(channel, pid) }, 3000);
                        setTimeout(function() { openBox(channel, pid) }, 6000);
                        return true;
                    case "std:re3":
                        setTimeout(function() { openBox(channel, pid) }, 3000);
                        setTimeout(function() { openBox(channel, pid) }, 6000);
                        setTimeout(function() { openBox(channel, pid) }, 9000);
                        return true;
                   case "std:x":
                        return true;
                    case "std:btnt":
                    case "std:joke":
                    case "std:icon":
                    case "std:theme":
                    case "std:cmd":
                        await inventoryModifyItem(pid, reward[0], 1);
                        return true;
                    default:
                        return false;
                }
            break;
            // COIN
            case "coin":
                id = +id;
                await modifyCoins(pid, id);
                return true;
            break;
            // GM / Alignment / Category / Special
            case "gm":
            case "al":
            case "cat":
            case "spec":
                await inventoryModifyItem(pid, reward[0], 1);
                return true;
            // BOT / Icon / Death Message / Skinpack
            case "bot":
            case "ic":
            case "dm":
            case "sp":
                let count = await inventoryModifyItem(pid, reward[0], 1);
                return count === 1;
            break;
            default:
                return true;
        }
    }
    
    /**
    Modifies item count in inventory
    **/
    this.inventoryModifyItem = async function(pid, item, count) {
        item = item.toLowerCase();
        let itemCount = await sqlPromEsc("SELECT * FROM inventory WHERE item=" + connection.escape(item) + " AND player=", pid);
        if(itemCount.length === 0) {
            await sqlProm("INSERT INTO inventory (player, item, count) VALUES (" + connection.escape(pid) + "," + connection.escape(item) + "," + connection.escape(count) + ")");
            return count;
        } else {
            if(itemCount[0].count + count === 0) { // delete
                await sqlPromEsc("DELETE FROM inventory WHERE item=" + connection.escape(item) + " AND player=", pid);
                return 0;
            } else {
                await sqlPromEsc("UPDATE inventory SET count=" + connection.escape(itemCount[0].count + count) + " WHERE item=" + connection.escape(item) + " AND player=", pid);
                return itemCount[0].count + count;
            }
        }
    }
    
    /**
    Retrieves item count in inventory
    **/
    this.inventoryGetItem = async function(pid, item) {
        item = item.toLowerCase();
        let itemCount = await sqlPromEsc("SELECT * FROM inventory WHERE item=" + connection.escape(item) + " AND player=", pid);
        return itemCount[0]?.count ?? 0;
    }


}